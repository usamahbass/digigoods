# Augment Guidelines for Digigoods API

## Code Styles

- Use Lombok to reduce boilerplate codes, especially when defining DTO classes.
- Refer to [`.editorconfig`](./.editorconfig) for general code styles such as indentation, line length, end-of-line symbols.
- Run `mvn checkstyle:check` to check for violations of Java code style. If violations found, read the report and try to fix them.
- Follow Spring Boot conventions for package organization and class naming.
- Use meaningful variable and method names that clearly express intent.
- Prefer composition over inheritance where appropriate.

## Testing Guidelines

### General Testing Principles
- New code should have corresponding unit tests with minimum 80% line coverage.
- Integration test of the API should be implemented using Spring's `MockMvc` that can run locally.
- Functional test of the API should be implemented using Postman collection that executed using `newman`.
- Make sure the tests still pass before and after making modification to the codebase.
- Use JUnit 5 test framework. To run the unit test suite, run `mvn test`. Make sure to run unit test suite before committing any code.

### Test Structure and Naming
- Follow the convention of Arrange-Act-Assert (AAA) for writing tests, including providing short one-liner comments that denote the sections.
- Name test methods using Given-When-Then format: `givenCondition_whenAction_thenExpectedResult`
- Add `@DisplayName` annotation to all test methods with descriptive names that explain the test scenario in plain English.
- Group related tests using `@Nested` classes with descriptive names.

### Test Method Examples
```java
@Test
@DisplayName("Should return product when valid ID is provided")
void givenValidProductId_whenFindById_thenReturnProduct() {
    // Arrange - setup test data and mocks
    
    // Act - execute the method under test
    
    // Assert - verify the expected outcome
}

@Test
@DisplayName("Should throw ProductNotFoundException when product ID does not exist")
void givenInvalidProductId_whenFindById_thenThrowProductNotFoundException() {
    // Test implementation
}
```

### Mock Usage Patterns
- Use `@MockBean` for Spring context integration tests.
- Use `@Mock` with `@ExtendWith(MockitoExtension.class)` for unit tests.
- Always verify mock interactions using `verify()` when the interaction is part of the expected behavior.
- Use `ArgumentCaptor` when you need to verify complex arguments passed to mocks.
- Prefer `when().thenReturn()` over `doReturn().when()` for better readability.

### Test Data and Setup
- Create test data using builder patterns or factory methods for complex objects.
- Use `@BeforeEach` for common setup that applies to multiple tests.
- Prefer creating minimal test data that focuses on the specific scenario being tested.
- Use meaningful test data values that make the test intent clear.

### Assertion Patterns
- Use AssertJ assertions (`assertThat()`) for better readability and error messages.
- Group related assertions together and use descriptive failure messages.
- For exception testing, use `assertThatThrownBy()` with specific exception types and messages.
- When testing collections, verify both size and content where relevant.

### Integration Test Patterns
- Use `@SpringBootTest` with `@AutoConfigureTestDatabase` for full integration tests.
- Use `@WebMvcTest` for controller layer testing with MockMvc.
- Use `@DataJpaTest` for repository layer testing.
- Always use `@ActiveProfiles("test")` to ensure test-specific configuration.

## Error Handling and Validation

- Always test both success and failure scenarios.
- Create specific test methods for each type of exception that can be thrown.
- Verify that error messages are meaningful and consistent.
- Test edge cases such as null inputs, empty collections, and boundary values.
- Ensure proper HTTP status codes are returned in controller tests.

## Code Coverage Requirements

- When asked to increase coverage for a specific source code file, check the coverage report first.
- The coverage report of a source code file can be found in `target/site/jacoco/[package name]/[class name].html`.
- When reading the coverage report, identify which lines and branches are not yet covered.
- Make sure to run `mvn test` before and after adding tests to verify coverage improvement.
- Aim for 100% line coverage on service classes and 90%+ on controllers.
- Focus on testing business logic thoroughly, including all conditional branches.

## Spring Boot Specific Guidelines

### Service Layer Testing
- Mock all external dependencies (repositories, other services).
- Test transactional behavior where applicable.
- Verify that service methods handle exceptions appropriately.
- Test business logic validation rules thoroughly.

### Controller Layer Testing
- Use MockMvc for testing HTTP endpoints.
- Test authentication and authorization scenarios.
- Verify request/response serialization.
- Test error handling and appropriate HTTP status codes.
- Include tests for request validation.

### Repository Layer Testing
- Use `@DataJpaTest` for repository testing.
- Test custom query methods thoroughly.
- Verify entity relationships and cascading behavior.
- Test constraint violations and database-specific behavior.

## Security Testing

- Test authentication scenarios (valid/invalid tokens).
- Test authorization scenarios (access control).
- Verify that sensitive data is not exposed in responses.
- Test CORS and security headers where applicable.

## Performance Considerations

- Avoid creating unnecessary objects in test setup.
- Use `@DirtiesContext` sparingly and only when necessary.
- Prefer unit tests over integration tests for better performance.
- Mock external services to avoid network calls in tests.
